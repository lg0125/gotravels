package com.chris.gotravels.frameworks.base.constant;

/**
 * 全局过滤器顺序执行常量类
 * */
public final class FilterOrderConstant {
    /**
     * 用户信息传递过滤器执行顺序排序
     * */
    public static final int USER_TRANSMIT_FILTER_ORDER = 100;
}

/*
* 1. 定义过滤器执行顺序
*
*
* 过滤器、拦截器或 AOP 组件的执行顺序为什么定义在基础组件库？
*
* 假设你的应用依赖了日志打印和幂等组件，方法执行时，需要打印日志和避免请求幂等
*
* 正常来说，要先打印日志，再触发幂等行为
* 但是，如果说日志和幂等的组件库开发者不是同一人，幂等在日志请求之前
* 如果不触发幂等还好，一旦触发幂等行为抛出异常，那么日志组件将不再执行
* 这对于生产日志以及排查问题来说非常不友好
*
* 所以说，每个基础组件的执行顺序需要在全局定义，
* 每个组件的开发者要有全局思维，定义类似于这种过滤器或拦截器或者AOP时，
*   需要从组件功能再结合全局组件功能考虑到执行顺序问题
*
* 正因为如此，将这些组件的执行顺序单独放到基础组件库中，
* 一个是基础组库被全部组件库依赖，
* 另一个就是定义组件时，也能看到其他组件库的功能以及执行顺序，避免出现信息孤岛问题
*
* 总得来说，有以下这些优势：
*    解耦和可复用性：
*       通过将组件库的执行顺序抽象到一个基础的组件库中，可以将各个组件库之间的依赖和执行顺序解耦
*       这样，每个组件库可以独立开发、测试和维护，提高了代码的可复用性和可维护性
*    灵活性：
*       由于执行顺序被抽象到基础组件库中，可以根据具体的业务需求对组件库进行配置，灵活地调整组件的执行顺序
*       这种灵活性使得开发人员可以根据具体的场景和需求来定义过滤器的执行顺序，提供更好的定制化和灵活性
*    执行顺序的统一管理：
*       将执行顺序抽象到一个基础组件库中，可以实现对所有组件库中过滤器执行顺序的统一管理
*       开发人员只需关注各个组件库的业务逻辑实现，而不必关心过滤器的具体执行顺序
*       这样可以简化开发流程，提高开发效率
*    扩展性：
*       基础组件库可以提供一些通用的功能和特性，例如全局变量的管理、过滤器的注册和执行等
*       这样可以为其他组件库提供扩展性，使其能够更好地适应不同的业务场景和需求
* */